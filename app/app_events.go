// Code generated by github.com/dashotv/golem. DO NOT EDIT.
package app

import (
	"fmt"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/pkg/errors"
	"go.uber.org/zap"

	flame "github.com/dashotv/flame/app"
	"github.com/dashotv/mercury"
)

func init() {
	initializers = append(initializers, setupEvents)
	healthchecks["events"] = checkEvents
}

type EventsChannel string
type EventsTopic string

func setupEvents(app *Application) error {
	events, err := NewEvents(app)
	if err != nil {
		return err
	}

	app.Events = events
	return nil
}

func checkEvents(app *Application) error {
	switch app.Events.Merc.Status() {
	case nats.CONNECTED:
		return nil
	default:
		return errors.Errorf("nats status: %s", app.Events.Merc.Status())
	}
}

type Events struct {
	App           *Application
	Merc          *mercury.Mercury
	Log           *zap.SugaredLogger
	Downloading   chan *EventDownloading
	Downloads     chan *EventDownloads
	Episodes      chan *EventEpisodes
	FlameCombined chan *FlameCombined
	Jobs          chan *EventJobs
	Logs          chan *EventLogs
	Movies        chan *EventMovies
	Notices       chan *EventNotices
	Releases      chan *Release
	Requests      chan *EventRequests
	SeerDownloads chan *EventSeerDownload
	SeerEpisodes  chan *EventSeerEpisode
	SeerLogs      chan *EventSeerLog
	SeerNotices   chan *EventSeerNotice
	Series        chan *EventSeries
}

func NewEvents(app *Application) (*Events, error) {
	m, err := mercury.New("tower", app.Config.NatsURL)
	if err != nil {
		return nil, err
	}

	e := &Events{
		App:           app,
		Merc:          m,
		Log:           app.Log.Named("events"),
		Downloading:   make(chan *EventDownloading),
		Downloads:     make(chan *EventDownloads),
		Episodes:      make(chan *EventEpisodes),
		FlameCombined: make(chan *FlameCombined),
		Jobs:          make(chan *EventJobs),
		Logs:          make(chan *EventLogs),
		Movies:        make(chan *EventMovies),
		Notices:       make(chan *EventNotices),
		Releases:      make(chan *Release),
		Requests:      make(chan *EventRequests),
		SeerDownloads: make(chan *EventSeerDownload),
		SeerEpisodes:  make(chan *EventSeerEpisode),
		SeerLogs:      make(chan *EventSeerLog),
		SeerNotices:   make(chan *EventSeerNotice),
		Series:        make(chan *EventSeries),
	}

	if err := e.Merc.Sender("tower.downloading", e.Downloading); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.downloads", e.Downloads); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.episodes", e.Episodes); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("flame.combined", e.FlameCombined); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.jobs", e.Jobs); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.logs", e.Logs); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.movies", e.Movies); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.notices", e.Notices); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.index.releases", e.Releases); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.requests", e.Requests); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("seer.downloads", e.SeerDownloads); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("seer.episodes", e.SeerEpisodes); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("seer.logs", e.SeerLogs); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("seer.notices", e.SeerNotices); err != nil {
		return nil, err
	}

	if err := e.Merc.Sender("tower.series", e.Series); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *Events) Start() error {
	e.Log.Infof("starting events...")
	go func() {
		// wire up receivers
		for {
			select {
			case m := <-e.FlameCombined:
				v, err := onFlameCombined(e.App, m)
				if err != nil {
					e.Log.Errorf("proxy failed: onFlameCombined: %s", err)
					continue
				}
				e.Send("tower.downloading", v)
			case m := <-e.SeerDownloads:
				v, err := onSeerDownloads(e.App, m)
				if err != nil {
					e.Log.Errorf("proxy failed: onSeerDownloads: %s", err)
					continue
				}
				e.Send("tower.downloads", v)
			case m := <-e.SeerEpisodes:
				v, err := onSeerEpisodes(e.App, m)
				if err != nil {
					e.Log.Errorf("proxy failed: onSeerEpisodes: %s", err)
					continue
				}
				e.Send("tower.episodes", v)
			case m := <-e.SeerLogs:
				v, err := onSeerLogs(e.App, m)
				if err != nil {
					e.Log.Errorf("proxy failed: onSeerLogs: %s", err)
					continue
				}
				e.Send("tower.logs", v)
			case m := <-e.SeerNotices:
				v, err := onSeerNotices(e.App, m)
				if err != nil {
					e.Log.Errorf("proxy failed: onSeerNotices: %s", err)
					continue
				}
				e.Send("tower.notices", v)
			}
		}
	}()
	return nil
}

func (e *Events) Send(topic EventsTopic, data any) error {
	f := func() interface{} { return e.doSend(topic, data) }

	err, ok := WithTimeout(f, time.Second*5)
	if !ok {
		e.Log.Errorf("timeout sending: %s", topic)
		return fmt.Errorf("timeout sending: %s", topic)
	}
	if err != nil {
		e.Log.Errorf("sending: %s", err)
		return errors.Wrap(err.(error), "events.send")
	}
	return nil
}

func (e *Events) doSend(topic EventsTopic, data any) error {
	switch topic {
	case "tower.downloading":
		m, ok := data.(*EventDownloading)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Downloading <- m

	case "tower.downloads":
		m, ok := data.(*EventDownloads)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Downloads <- m

	case "tower.episodes":
		m, ok := data.(*EventEpisodes)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Episodes <- m

	case "tower.jobs":
		m, ok := data.(*EventJobs)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Jobs <- m

	case "tower.logs":
		m, ok := data.(*EventLogs)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Logs <- m

	case "tower.movies":
		m, ok := data.(*EventMovies)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Movies <- m

	case "tower.notices":
		m, ok := data.(*EventNotices)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Notices <- m

	case "tower.index.releases":
		m, ok := data.(*Release)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Releases <- m

	case "tower.requests":
		m, ok := data.(*EventRequests)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Requests <- m

	case "tower.series":
		m, ok := data.(*EventSeries)
		if !ok {
			return errors.Errorf("events.send: wrong data type: %t", data)
		}
		e.Series <- m
	default:
		e.Log.Warnf("events.send: unknown topic: %s", topic)
	}
	return nil
}

type EventDownloading struct { // downloading
	Downloads map[string]*Downloading `bson:"downloads,omitempty" json:"downloads,omitempty"`
	Hashes    map[string]string       `bson:"hashes,omitempty" json:"hashes,omitempty"`
	Metrics   *flame.Metrics          `bson:"metrics,omitempty" json:"metrics,omitempty"`
}

type EventDownloads struct { // downloads
	Event    string    `bson:"event,omitempty" json:"event,omitempty"`
	Id       string    `bson:"id,omitempty" json:"id,omitempty"`
	Download *Download `bson:"download,omitempty" json:"download,omitempty"`
}

type EventEpisodes struct { // episodes
	Event   string   `bson:"event,omitempty" json:"event,omitempty"`
	Id      string   `bson:"id,omitempty" json:"id,omitempty"`
	Episode *Episode `bson:"episode,omitempty" json:"episode,omitempty"`
}

type EventJobs struct { // jobs
	Event string  `bson:"event,omitempty" json:"event,omitempty"`
	Id    string  `bson:"id,omitempty" json:"id,omitempty"`
	Job   *Minion `bson:"job,omitempty" json:"job,omitempty"`
}

type EventLogs struct { // logs
	Event string   `bson:"event,omitempty" json:"event,omitempty"`
	Id    string   `bson:"id,omitempty" json:"id,omitempty"`
	Log   *Message `bson:"log,omitempty" json:"log,omitempty"`
}

type EventMovies struct { // movies
	Event string `bson:"event,omitempty" json:"event,omitempty"`
	Id    string `bson:"id,omitempty" json:"id,omitempty"`
	Movie *Movie `bson:"movie,omitempty" json:"movie,omitempty"`
}

type EventNotices struct { // notices
	Event   string `bson:"event,omitempty" json:"event,omitempty"`
	Time    string `bson:"time,omitempty" json:"time,omitempty"`
	Class   string `bson:"class,omitempty" json:"class,omitempty"`
	Level   string `bson:"level,omitempty" json:"level,omitempty"`
	Message string `bson:"message,omitempty" json:"message,omitempty"`
}

type EventRequests struct { // requests
	Event   string   `bson:"event,omitempty" json:"event,omitempty"`
	Id      string   `bson:"id,omitempty" json:"id,omitempty"`
	Request *Request `bson:"request,omitempty" json:"request,omitempty"`
}

type EventSeries struct { // series
	Event  string  `bson:"event,omitempty" json:"event,omitempty"`
	Id     string  `bson:"id,omitempty" json:"id,omitempty"`
	Series *Series `bson:"series,omitempty" json:"series,omitempty"`
}
